## 滑动窗口笔记

[toc]

### 1.滑动窗口的是什么

滑动窗口算法，这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：

```java
int left = 0, right = 0;

while (right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;
while (window needs shrink) {
    // 缩小窗口
    window.remove(s[left]);
    left++;
}
```
}
这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。



### 2.滑动窗口代码模板

~~~java
public String minWindow(String s, String t) {
   		// 窗口本身
        HashMap<Character, Integer> window = new HashMap<>();
    	// 需要达到的目标
        HashMap<Character, Integer> need = new HashMap<>();
    	// 左边界，右边界 计数器
        int left = 0, right = 0, valid = 0;
       
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            //右移动窗口更新窗口数据 。
             ...
			
            // 判断左窗口是否需要收缩
            while (收缩条件) {
                char d = s.charAt(left);
                left++;
                // 左移动窗口更新数据
              	...
            }
        }
        return res;
    }
~~~

其中需要注意的是：1.右移动窗口和左移窗口都是移动一个字符。2.什么时候收获结果集 考虑两个节点 左边界更新收缩完成、每次收缩左边界时。

### 3.具体例子

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

套入框架

~~~java
class Solution {
   public List<Integer> findAnagrams(String s, String p) {
        HashMap<Character, Integer> window = new HashMap<>();
        HashMap<Character, Integer> need = new HashMap<>();
       // valid 技术器是用来判断是否可以收割结果集的标志
        int left = 0, right = 0, valid = 0;
        // 结果集
        List<Integer> res = new ArrayList<>();
       // 填充need集即是p中每个字符字符出现的次数
        for (Character c : p.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
       
       // 遍历目标集
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
			
            // 添加到窗口中的字符需要根据题意，有时是是直接增加，有时有条件
            if (need.containsKey(c)) {
                // 符合要求增大更新窗口
                window.put(c, window.getOrDefault(c, 0) + 1);
             	// 当某个字符出现的次数达到目标次数时 增加计数器
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }

            // 收缩窗口一定是while 而不是if
            while (right - left + 1 > p.length()) {
                char d = s.charAt(left);
                // 达到条件收获结果集
                if (valid == need.size()) {
                    res.add(left);
                }
                left++;
                // 跟新计数器
                if (window.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.getOrDefault(d, 0) - 1);
                }
            }
        }
        return res;
    }
}
~~~

此类问题都属于字符串的子串问题，当输入的是s,p两个字符串是直接使用代码模板，当只有一个输入s时如3.无重复字符的最长子串,只需要稍微修改模板就行，不再需要valid计数器和need 反而变得更加简单了。

读完本文，你可以去力扣拿下如下题目：

[76.最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)

[567.字符串的排列](https://leetcode-cn.com/problems/permutation-in-string)

[438.找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)

[3.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)