### 完全背包问题


[toc]

#### 一、完全背包与01背包的区别

01背包每一种物品只能够使用一次而完全背包可以无限次使用同一种物品体现在代码方面如下

```java
for (int i = 0; i < m; i++) {
	for (int j = weight[i]; j <= n; j++) {
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        //System.out.println("dp[" + j + "] = " + dp[j]);
    }
}
```

**完全背包在遍历背包时需要正向遍历这样才能够体现每一个物品可以多次使用**

#### 二、完全背包常见题型

##### 2.1 背包空间为n能装的最大价值？

题目连接：[https://kamacoder.com/problempage.php?pid=1052](https://kamacoder.com/problempage.php?pid=1052)<br />这是一道最基本的完全背包问题，和01背背包的区别为在遍历背包的时候需要从前向后遍历，这样才能够重复使用每一种物品。<br />题解代码：

```java
/**
 * @author 小木蕊
 * @address xiaomurui@163.com https://gitee.com/poxiao02
 * @createDate 2024/6/1 16:53
 * @description 完全背包
 */
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //m 材料种类，n背包大小
        int m = 0, n = 0;
        m = in.nextInt();
        n = in.nextInt();
        int[] weight = new int[m];
        int[] value = new int[m];
        for (int i = 0; i < m; i++) {
            weight[i] = in.nextInt();
            value[i] = in.nextInt();
        }
        int[] dp = new int[n + 1];
        for (int i = 0; i < m; i++) {
            for (int j = weight[i]; j <= n; j++) {
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
                //                System.out.println("dp[" + j + "] = " + dp[j]);
            }
        }
        System.out.println(dp[n]);
    }
}
```

##### 2.2 有多少种装法（求组合数）？

题目链接：[https://leetcode.cn/problems/coin-change-ii/](https://leetcode.cn/problems/coin-change-ii/)<br />对于这种问有多少种装法的问题只需要在dp定义dp公式上改动即可，假设我们需要求dp[5]:<br />dp[j]为价值为j的物品有dp[j]种装法,dp[0] 初始化为1<br />第1种情况：现在背包里有1个物品则 dp[5] = dp[5-1];<br />第2种情况：现在背包里有2个物品则 dp[5] = dp[5-2];<br />第3种情况：现在背包里有3个物品则 dp[5] = dp[5-3];<br />第4种情况：现在背包里有4个物品则 dp[5] = dp[5-4];<br />第5种情况：现在背包里有5个物品则 dp[5] = dp[5-5];<br />综上 **dp[j] +=dp[j-value[i]]**<br />**组合数：先物品再背包**<br />**题解代码：**

```java
class Solution {
     public int change(int amount, int[] coins) {
        // 1.dp数组的定义：dp[j] 表示金额为j的价值有dp[j]种组成方式
        int[] dp = new int[amount + 1];
        // 2.dp递推公式：dp[j] += dp[j - coins[i]];
        // 3.初始化 dp[0] 只有一种组成方式就是不放，其余无需初始化
        dp[0] = 1;
        // 4，遍历顺序， 先物品再背包正序遍历（完全背包）
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
                // 5.打印dp数组
                //System.out.println("dp[" + j + "] = " + dp[j]);
            }
        }
        return dp[amount];
    }
}
```

##### 2.3 有多少总装法，并且不同的装入顺序算作是不用的种类（求排列数）？

**题目链接：**[**https://leetcode.cn/problems/combination-sum-iv/**](https://leetcode.cn/problems/combination-sum-iv/)<br />在面对最多有几种装法，并且强调不同的顺序也算是不同的组合时，只需要改变遍历顺序即可，因为先物品在背包的顺序是不强调顺序的，会先将物品从前向后遍历一遍出现 物品2 、物品1、物品2，但是先背包在物品的顺序可以做到。<br />**题解代码：**

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // 1.dp数组的定义；dp[j]表示价值为j的背包有dp[j]种装法
        int[] dp = new int[target + 1];
        // 2.dp递推公式：dp[j] += dp[j - nums[i]];
        // 3.dp初始化 价值为0只有一种装法
        dp[0] = 1;
        // 4.遍历顺序 先背包再物品，可以区别不同的组合
        for (int j = 1; j <= target; j++) {
            for (int i = 0; i < nums.length; i++) {
                if (j >= nums[i]) {
                    dp[j] += dp[j - nums[i]];
                    // 5打印dp数组
                    // System.out.println("dp[" + j + "] = " + dp[j]);
                }
            }
        }
        return dp[target];
    }
}
```

##### 2.4 装满最少需要多个物品？

题目链接：[https://leetcode.cn/problems/coin-change/](https://leetcode.cn/problems/coin-change/)<br />面对最少物品个数的情况是，需要将在初始化的时候将0下标初始化为：dp[0]=0，非0下标初始化为最大值，这样在跟新dp数组时才能够确保值不会被初始值覆盖，dp递推公式为dp[j] = min.(dp[j-weight[j]]+1,dp[j])<br />**排列数：先背包再物品**<br />**题解代码：**

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 1.dp数组定义dp[j] 为金额为j需要的最小货币数
        int[] dp = new int[amount + 1];
        // 2.dp递推公式dp[j] = min(dp[j-coins[i]+1,dp[j])
        // 3.初始化因为要求最小值非0下标初始为最大值防止覆盖
        dp[0] = 0;
        for (int j = 1; j <= amount; j++) {
            dp[j] = Integer.MAX_VALUE;
        }
        // 4.遍历顺序 先物品后背包，后背包正向，完全背包
         for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j-coins[i]]==Integer.MAX_VALUE)
                    continue;
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                // 5.打印dp数组验证
                //System.out.println("dp[" + j + "] = " + dp[j]);
            }
        }
        if (dp[amount] == Integer.MAX_VALUE)
            return -1;
        return dp[amount];
    }
}
```

##### 2.5 是否可以装满问题？

题目链接：[https://leetcode.cn/problems/word-break/description/](https://leetcode.cn/problems/word-break/description/)<br />这是一题求是否可以装满的且是求排列数的问题，那么就一定要先遍历背包再遍历物品。<br />**题解代码：**

```java
 public boolean wordBreak(String s, List<String> wordDict) {
        // 1.dp[j] 表示长度j的支付串是否可与由wordDict组成
        // 2.dp递推公式String temp = s.substring(i, j);
        //                if (set.contains(temp) && dp[i]) {
        //                    dp[j] = true;
        //                }
        // [i-j]区间的字符串可以由wordDict组成且dp[i]==true
        // 3.初始化：dp[0] = true;其余初始为false
        HashSet<String> set = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        // 4.遍历顺序 先背包后物品 求排列数
        for (int j = 1; j <= s.length(); j++) {
            for (int i = 0; i < j; i++) {
                String temp = s.substring(i, j);
                if (set.contains(temp) && dp[i]) {
                    dp[j] = true;
                }
                // 5.打印dp数组
                System.out.println("dp[" + j + "] = " + dp[j]);
            }
        }
        return dp[s.length()];
    }
```

#### 三、总结

无论在面对面对什么类型的背包问题时，都需要回顾基础的动态规划五部：

1. dp数组的定义，这很关键一般是就是直接的题目的问题
2. dp递推公式，这个需要靠多练多积累灵活的变动
3. dp初始化，常见的去考虑0下标和非0下标
4. 遍历顺序：是先背包还是先物品，正序还是倒叙
5. 打印dp数组对比和推到的过程是否一致。

