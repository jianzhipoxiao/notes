# HashMap 原理笔记

### 一  Key hash 的计算原理

#### **1. Key Hash 的计算过程**

![image-20240809191348406](C:\Users\ll159\AppData\Roaming\Typora\typora-user-images\image-20240809193914783.png)

~~~java
// 获取hashCode "abc".hashCode();
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
~~~

#### 2. HashMap 常见面试题

**1.HashCode的为什么有 31 这个固定值**

1. HashCode 是一个获取对象的唯一值的函数，具体作用是生成一个 [-2147483648,2147483648] 范围在 40 亿的唯一值。为什么使用 31 做为乘数？
   - 31 是一个奇质数偶数会溢出。
   - 31 可以用二进制优化计算 `31 * i == (i << 5) - i`
   - 根据实验数据所得

**2.扰动函数有什么作用**

为什么需要扰动函数，在不使用扰动函数时 hashCode 会分布不均匀，造成 hash 碰撞从而会损耗性能，违背 Hash 设计之初随机存储 O(1) 的初衷。使用扰动函数后Hash 分布会均匀很多。怎么做扰动函数：`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`。

**3.Map** 初始化为 2 的幂好处

在 HashMap 在扩容时会使用`e.hash&oldCap`做判断需要 二进制类似10000做计算，如果选择 17 会设置为第一个比其大的2 的幂即为 32。

**4.怎么扩容**

JDK 1.7 之前需要重新计算 Hash 值，JDK1.8后优化了性能不再需要 直接平移过去，或者原位置+OldCap，如此一来可以减少 Hash 的计算提高扩容的性能。

**5.扩容因子**

0.75 是默认的因子，也可以自己指定，但是这个值是一个空间和时间比较均均衡的点。本质上是空间换时间，值变小了就是更多的空间消耗换来更少的 Hash 碰撞，反正依然。



### 二. 红黑树解决 Hash 冲突

#### 1. 二叉树前生

**红黑树前生 2-3 树**

二叉搜索树是保证数据查找为 O(log2N) 的关键但是在特殊情况插入数据为 1，2，3，4，5 时二叉树会退化为链表，从而导致 效率从 O(log2N) 退化到 O(N)。如图

![image-20240810161846527](https://s2.loli.net/2024/08/11/b12TJ3D9tVaSLfX.png)



2-3 树是红黑树的前生，为解决退化问题的一种特殊的数据结构有，如下特点：

| 1    | 每个根可有一个或者两个数据节点                               |
| ---- | ------------------------------------------------------------ |
| 2    | 一个根有一个数据节点两个叉                                   |
| 3    | 一个根有两个数据节点有三个叉                                 |
| 3    | 三个叉 小于根的在左边，中间为介于两个数据节点间的，右边为大于 |
| 5    | 每个根达到三个数据节点时会转换为一棵二叉树                   |
| 6    | **2-3树所有子叶节点都在同一层**                              |

![image-20240810164610197](https://s2.loli.net/2024/08/11/RfPGaK5JUp8NEyi.png)

#### 2. 红黑树特点

**为什么有了2-3树还需要红黑树**

2-3 树已经很好的解决了二叉收缩树退化为链表的问题，但是在代码的编写上却不是很方便，在查找一个元素时需要经历两次判断。在编写代码方便我们跟喜欢**非此即彼**,也就是二叉树这个样的结构，所以又将 2-3 树优化为红黑树。

![image-20240811134933987](../../../../../AppData/Roaming/Typora/typora-user-images/image-20240811134933987.png)

**红黑树的特征**

1. 根节点为黑色，每个节点不是黑色就是红色。
2. 所有的叶子节点为黑色（这里指为null的部分）
3. 从根节点到叶子节点的每一条路劲经过的黑色节点相同。
4. 两个红色节点不能相连

![image-20240811140339613](../../../../../AppData/Roaming/Typora/typora-user-images/image-20240811140339613.png)

红黑树的特点让他可以在二叉搜索树和平衡二叉搜索树之间做一个折衷的方案，性能比平衡二叉搜索树好，同时也不会像二叉搜索树一样极端情况下退化为链表。红黑树在建立的时候会将所有的节点先按红色插入，然后染色旋转。正因为红黑树优秀的性能表现在能够够在诸多API中见到其的声影如：HashMap、TreeMap.

红黑树可视化网站：[Red/Black Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)