

### JVM 笔记总结

[toc]

### 一 运行时数据分区

JVM内存结构模型为 堆、方法区、虚拟机栈、本地方法栈、程序计数器。堆和方法区是线程共享的，虚拟机栈、本地方法栈、程序计数器是每个线程独有的。

![JVM虚拟机-运行时数据分区.drawio](https://s2.loli.net/2024/07/04/1gDLChrRSeAQBoI.png)

**堆**：对象分配内存地址的区域，也是垃圾回收的主要区域，也叫`GC堆`，分为**老年代**和**新生代**

**方法区**：存储常量的区域如：类、字符串常量，一般来说不做垃圾回收，因为回收的效果不好，也叫做`永生代`

**虚拟机栈**：JVM虚拟的一般方法执行的栈

**本地方法栈**：Native方法执行的栈

### 二 对象

#### 2.1 对象的创建过程

![JVM虚拟机-对象生成过程.drawio](https://s2.loli.net/2024/07/04/jmLRIyp4x7vBX8a.png)

#### 2.2 对象的组成

对象分为对象头、实例数据、对象填充三部分

![JVM虚拟机-Object结构.drawio](https://s2.loli.net/2024/07/04/ZJ4yD85FGgKSUEu.png)

### 三 垃圾回收

#### 3.1 对象死亡检测

当一个对象被判定死亡时，就要被面临没回收的风险。后续可以通过某种手段自救一次。

**引用技术器算法**：引用计算器算法是用一个计数器统计每个对象的引用次数

优点：简单高效

缺点：两个对象互相引用，但是两个对象不再被其他地方使用，则一直不会判定为死亡。

**可达性分析算法**：从GC Root开始建立有向图，如果某个节点没有从 Root节点到达的路劲，则判断这个节点的死亡。

GC Roots对象的种类：

- 虚拟机栈（栈帧中变量表）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量对象引用的对象
- 本地方法栈中JNI（Native 方法）引用的对象

#### 3.2 垃圾回收算法

**标记-清除算法**：标记清楚算法是将内存中需要回收的对象标记，然后清除，效率不高且会造成内存碎片。

**复制算法**：将内存分为两块，只使用其中的一块，当GC回收的时候，将存活对象复制到未使用的一边中，直接清除原有一半，解决内存碎片问题，但是对内存的利用率不高，改进在新生代中将内存大小分配为 8:1，这样只会浪费10%的内存。

**标记整理算法**：

**分代收集算法**：



#### **3.3** 垃圾回收器

> 吞吐量就是CPU用于运行用户代码
> 的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间／（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是 99%。

**CMS**

老年代收集器，追求低停顿，采用 “标记-清除算法”。

收集过程：

1. 初始标记：初略标记 `GC root`可以直接到达的对象，暂停用户线程，消耗时间较短。
2. 并发标记：标记`GC root`可以到达的对象，消耗时间长，可以和用户线程并发执行。
3. 重新标记：再次标记并发标记期间用户线程需要回收的对象。暂停用户线程。
4. 并发清除：清除垃圾，回收堆的内存，可以和用户线程并发执行，在此期间会产生[^浮动垃圾]

优点：低停顿的GC回收器

缺点：

1. 会产生不连续的内存，无法为较大的对象分配内存，不得不提前触发 Full GC
2. 无法处理**浮动垃圾**，可能会出现“Concurrent Mode Failure”失败而导致另一次[^Full GC]的产生,切换为Serial Old收集，从而会造成更加长时间的停顿。
3. 对 CPU资源敏感，4个以上CPU会造成不少于25%的资源用于线程收集，当只有两个CPU时会提升至50%。

**G1垃圾回收器**

将老年代和新生代统一划分为 Region ,不再需要像其它的垃圾回收其一样需要对整个新生代或老年代进行收集。

特点：

- 并发与并行：G1可以与用户线程并发运行，利用多核cpu的优势缩短用户线程
- 分代收集： G1仍然采用分代收集的思想来处理不同对象，（老年代的对象收集效率不高故需要分代）
- 空间的整理：G1整体采用类似于“标记-整理”回收算法，两个Region间采用“标记-复制”回收算法，不用产生内存碎片。
- 可预测停顿：G1和CMS都是低停顿垃圾回收器，但是G1可以在约定的时间片M毫秒内，将垃圾回收时间控制在不超过N毫秒。

G1为什么可以做到可预测停顿，

收集过程：G1会追踪每一个Region 堆，维护一个优先级列表，优先回收价值最大的Region，保证G1的回收效率

1. 初始标记：初略标记 `GC root`可以直接到达的对象，暂停用户线程，消耗时间较短。
2. 并发标记：对堆中的对象做可达性分析，耗时较长，可以与用户线程并发执行。
3. 最终标记：对并发标记阶段用户线程产生的垃圾进行修正，记录到Remembered Set Logs 并合并到Remembered Set 中，需要暂停用户线程，但是GC线程可以并行执行。
4. 筛选回收：对每一个 Region 进行排序,根据用户期望的GC回收时间来制定回收计划。

大应用程序大内存使用 G1 否则使用 CMS，大内存的界限是 6G。



####  3.4 GC类型

**Full GC**

1. **回收范围**：
   - Full GC会回收整个堆，包括新生代（Young Generation）和老年代（Old Generation），有时还包括永久代（在JDK 8之前）或元空间（Metaspace，在JDK 8及之后）。

2. **停顿时间**：
   - Full GC会暂停所有应用程序线程（Stop-the-World），通常停顿时间较长，因为需要遍历和回收整个堆内存的垃圾。

3. **触发条件**：
   - 老年代空间不足。
   - 显式调用`System.gc()`。
   - CMS垃圾收集器的“Concurrent Mode Failure”。
   - 晋升失败，即新生代对象无法晋升到老年代。

**Minor GC（Young GC）**

1. **回收范围**：
   - Minor GC只回收新生代（Young Generation）的垃圾。新生代通常划分为Eden区和两个Survivor区。

2. **停顿时间**：
   - Minor GC也会暂停所有应用程序线程，但因为只回收新生代，停顿时间相对较短。

3. **触发条件**：
   - 新生代空间不足。当Eden区空间不足时，Minor GC会被触发。

**Major GC（Old GC）**

1. **回收范围**：
   - Major GC主要回收老年代（Old Generation）的垃圾。

2. **停顿时间**：
   - Major GC也会暂停所有应用程序线程，停顿时间比Minor GC长，因为老年代通常比新生代大，回收时间也更长。

3. **触发条件**：
   - 老年代空间不足。

**Mixed GC（特指G1 GC）**

1. **回收范围**：
   - Mixed GC回收一部分新生代和一部分老年代的垃圾。

2. **停顿时间**：
   - Mixed GC的停顿时间介于Minor GC和Full GC之间，通过选择性回收部分区域来减少停顿时间。

3. **触发条件**：
   - 由G1垃圾收集器的策略决定，通常在需要回收老年代的一部分时触发。

**总结**

- **回收范围**：Full GC回收整个堆，Minor GC只回收新生代，Major GC回收老年代，Mixed GC回收部分新生代和老年代。
- **停顿时间**：Full GC停顿时间最长，Minor GC停顿时间最短，Major GC停顿时间较长，Mixed GC停顿时间介于Minor GC和Full GC之间。
- **触发条件**：不同类型的GC有不同的触发条件，通常与内存空间的使用情况和垃圾收集器的策略有关。

选择合适的垃圾收集器和调优垃圾收集策略可以帮助优化GC的性能和应用程序的响应时间。

### 四 类加载器

**类加载过程**

![JVM虚拟机-类加载.drawio](https://s2.loli.net/2024/08/05/eU63xJ7mNKhvYzA.png)

#### 4.1 触发类加载的条件

1. 遇到 **new、getstatic、putstatic 或 invokestatic **这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放人常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 反射包调用类方法时，没有初始化会触发。
3. 子类初始化时父类未初始化，促使父类初始化。接口只有在这一点和类不一样。
4. main 方法在启动时会初始化其所在的类。
5. 当使用 JDK l.7 的动态语言支持时，如果一个 java.lang.invoke..MethodHandle实例最
   后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

#### 4.2 双亲委派

**加载器分类**

- 启动类加载器：由虚拟机调用，Java 程序无法直接调用，果需要把加载请求委派给引导类加载器，那直接使用null代替即可
- 扩展类加载器( Extension Class Loader ):这个加载器由sun.misc.Launcher$ExtClass Loader 实现，它负责加载<JAVA HOME\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序加载器：加载用户类路径上的库类，应用程序没有自定义类加载器，使用该类加载器。

![image-20240805111651153](https://s2.loli.net/2024/08/05/IkUyTfu4VaHlroA.png)

使用组合的方式每一个类加载器都有一个父类加载器，在类加载的时候，优先使用父类加载，如果是父类找不到，再用自己的类加载器。

**优点** : 

1. 确保类的安全性：确保类在加载时的顺序，保证加载的安全和一致性。
2. 避免类的重复加载
3. 简化类的加载设计

**特殊违背双亲委派原则**：

1. 向前兼容：JDK 1.2 之前为了让用户习惯双亲委派码，Java 设计者引人双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的 java.lang.ClassLoader添加了一个新的 protected 方法 findClass（）,在此之前，用户去继承javalang.ClassLoader的唯一目的就是为了重写 loadClass(）方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternalO,而这个方法的唯一逻辑就是去调用自己的loadClass().
2. 模型自生缺陷：上层的代码需要使用到下层的类加载器，如 JDBC ,引入线程上下文加载器，在线程创建时可以指定加载器，如果不指定默认继承父类的。
3. 用户追求极致的动态性：热部署这类的技术，比如 OSGI 技术在类加载时不是完全按照 双亲委派模型来设计。

###### 

[^浮动垃圾]: 用户线程和GC线程并发执行期间产生的需要回收的对象垃圾,无法在本次收集中处理，需要下一次GC处理。
[^Full GC]: 触发垃圾回收，暂停用户线程，回收新生代和老年代的内存。

