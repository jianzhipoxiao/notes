### JVM 笔记总结

### 一 运行时数据分区

JVM内存结构模型为 堆、方法区、虚拟机栈、本地方法栈、程序计数器。堆和方法区是线程共享的，虚拟机栈、本地方法栈、程序计数器是每个线程独有的。

![JVM虚拟机-运行时数据分区.drawio](https://s2.loli.net/2024/07/04/1gDLChrRSeAQBoI.png)

**堆**：对象分配内存地址的区域，也是垃圾回收的主要区域，也叫`GC堆`，分为**老年代**和**新生代**

**方法区**：存储常量的区域如：类、字符串常量，一般来说不做垃圾回收，因为回收的效果不好，也叫做`永生代`

**虚拟机栈**：JVM虚拟的一般方法执行的栈

**本地方法栈**：Native方法执行的栈

### 二 对象

#### 2.1 对象的创建过程

![JVM虚拟机-对象生成过程.drawio](https://s2.loli.net/2024/07/04/jmLRIyp4x7vBX8a.png)

#### 2.2 对象的组成

对象分为对象头、实例数据、对象填充三部分

![JVM虚拟机-Object结构.drawio](https://s2.loli.net/2024/07/04/ZJ4yD85FGgKSUEu.png)

### 三 垃圾回收

#### 3.1 对象死亡检测

当一个对象被判定死亡时，就要被面临没回收的风险。后续可以通过某种手段自救一次。

**引用技术器算法**：引用计算器算法是用一个计数器统计每个对象的引用次数

优点：简单高效

缺点：两个对象互相引用，但是两个对象不再被其他地方使用，则一直不会判定为死亡。

**可达性分析算法**：从GC Root开始建立有向图，如果某个节点没有从 Root节点到达的路劲，则判断这个节点的死亡。

GC Roots对象的种类：

- 虚拟机栈（栈帧中变量表）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量对象引用的对象
- 本地方法栈中JNI（Native 方法）引用的对象

#### 3.2 垃圾回收算法

**标记-清除算法**：标记清楚算法是将内存中需要回收的对象标记，然后清除，效率不高且会造成内存碎片。

**复制算法**：将内存分为两块，只使用其中的一块，当GC回收的时候，将存活对象复制到未使用的一边中，直接清除原有一半，解决内存碎片问题，但是对内存的利用率不高，改进在新生代中将内存大小分配为 8:1，这样只会浪费10%的内存。

**标记整理算法**：

**分代收集算法**：



#### **3.3** 垃圾回收器

> 吞吐量就是CPU用于运行用户代码
> 的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间／（运行用户代码时间+
> 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是
> 99%。

**CMS**

老年代收集器，追求低停顿，采用 “标记-清除算法”。

收集过程：

1. 初始标记：初略标记 `GC root`可以直接到达的对象，暂停用户线程，消耗时间较短。
2. 并发标记：标记`GC root`可以到达的对象，消耗时间长，可以和用户线程并发执行。
3. 重新标记：再次标记并发标记期间用户线程需要回收的对象。暂停用户线程。
4. 并发清除：清除垃圾，回收堆的内存，可以和用户线程并发执行，在此期间会产生[^浮动垃圾]

优点：低停顿的GC回收器

缺点：

1. 会产生不连续的内存，无法为较大的对象分配内存，不得不提前触发 Full GC
2. 无法处理**浮动垃圾**，可能会出现“Concurrent Mode Failure”失败而导致另一次[^Full GC]的产生,切换为Serial Old收集，从而会造成更加长时间的停顿。
3. 对 CPU资源敏感，4个以上CPU会造成不少于25%的资源用于线程收集，当只有两个CPU时会提升至50%。

**G1垃圾回收器**

将老年代和新生代统一划分为 Region ,不再需要像其它的垃圾回收其一样需要对整个新生代或老年代进行收集。

特点：

- 并发与并行：G1可以与用户线程并发运行，利用多核cpu的优势缩短用户线程
- 分代收集： G1仍然采用分代收集的思想来处理不同对象，（老年代的对象收集效率不高故需要分代）
- 空间的整理：G1整体采用类似于“标记-整理”回收算法，两个Region间采用“标记-复制”回收算法，不用产生内存碎片。
- 可预测停顿：G1和CMS都是低停顿垃圾回收器，但是G1可以在约定的时间片M毫秒内，将垃圾回收时间控制在不超过N毫秒。

G1为什么可以做到可预测停顿，

收集过程：G1会追踪每一个Region 堆，维护一个优先级列表，优先回收价值最大的Region，保证G1的回收效率

1. 初始标记：初略标记 `GC root`可以直接到达的对象，暂停用户线程，消耗时间较短。
2. 并发标记：对堆中的对象做可达性分析，耗时较长，可以与用户线程并发执行。
3. 最终标记：对并发标记阶段用户线程产生的垃圾进行修正，记录到Remembered Set Logs 并合并到Remembered Set 中，需要暂停用户线程，但是GC线程可以并行执行。
4. 筛选回收：对每一个 Region 进行排序,根据用户期望的GC回收时间来制定回收计划。

####  3.4 GC类型

**Full GC**

1. **回收范围**：
   - Full GC会回收整个堆，包括新生代（Young Generation）和老年代（Old Generation），有时还包括永久代（在JDK 8之前）或元空间（Metaspace，在JDK 8及之后）。

2. **停顿时间**：
   - Full GC会暂停所有应用程序线程（Stop-the-World），通常停顿时间较长，因为需要遍历和回收整个堆内存的垃圾。

3. **触发条件**：
   - 老年代空间不足。
   - 显式调用`System.gc()`。
   - CMS垃圾收集器的“Concurrent Mode Failure”。
   - 晋升失败，即新生代对象无法晋升到老年代。

**Minor GC（Young GC）**

1. **回收范围**：
   - Minor GC只回收新生代（Young Generation）的垃圾。新生代通常划分为Eden区和两个Survivor区。

2. **停顿时间**：
   - Minor GC也会暂停所有应用程序线程，但因为只回收新生代，停顿时间相对较短。

3. **触发条件**：
   - 新生代空间不足。当Eden区空间不足时，Minor GC会被触发。

**Major GC（Old GC）**

1. **回收范围**：
   - Major GC主要回收老年代（Old Generation）的垃圾。

2. **停顿时间**：
   - Major GC也会暂停所有应用程序线程，停顿时间比Minor GC长，因为老年代通常比新生代大，回收时间也更长。

3. **触发条件**：
   - 老年代空间不足。

**Mixed GC（特指G1 GC）**

1. **回收范围**：
   - Mixed GC回收一部分新生代和一部分老年代的垃圾。

2. **停顿时间**：
   - Mixed GC的停顿时间介于Minor GC和Full GC之间，通过选择性回收部分区域来减少停顿时间。

3. **触发条件**：
   - 由G1垃圾收集器的策略决定，通常在需要回收老年代的一部分时触发。

**总结**

- **回收范围**：Full GC回收整个堆，Minor GC只回收新生代，Major GC回收老年代，Mixed GC回收部分新生代和老年代。
- **停顿时间**：Full GC停顿时间最长，Minor GC停顿时间最短，Major GC停顿时间较长，Mixed GC停顿时间介于Minor GC和Full GC之间。
- **触发条件**：不同类型的GC有不同的触发条件，通常与内存空间的使用情况和垃圾收集器的策略有关。

选择合适的垃圾收集器和调优垃圾收集策略可以帮助优化GC的性能和应用程序的响应时间。

### 四 类加载器



[^浮动垃圾]: 用户线程和GC线程并发执行期间产生的需要回收的对象垃圾,无法在本次收集中处理，需要下一次GC处理。
[^Full GC]: 触发垃圾回收，暂停用户线程，回收新生代和老年代的内存。

