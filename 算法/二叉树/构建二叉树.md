## 构建二叉树

### 情景
根据一棵树的中序遍历与后序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

例如，给出
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3] 
### 任务
返回如下的二叉树：

![img.png](https://s2.loli.net/2024/04/02/hJZmeb8pdwYR9HA.png)

### 行动
1. 后序遍历的最后一个元素为根元素
![img_1.png](https://s2.loli.net/2024/04/02/BuUeaMwdDFjSz1T.png)
2. 切割中序遍历
![img_2.png](https://s2.loli.net/2024/04/02/tiqb1je4KLnmaRB.png)
3. 切割后序遍历
![img_3.png](https://s2.loli.net/2024/04/02/jrGE2FMavgwZ6P7.png)
4. 递归重复切割

### 结果

~~~Java
class Solution {
    
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return traversal(inorder, postorder);
    }

    //1确定参数类别和返回值
    TreeNode traversal(int[] inorder, int[] postorder) {
        //2确定返回值
        if (postorder.length == 0) return null;

        //3确定单层的逻辑
        //找到根节点
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        if (postorder.length == 1) return root;

        //切割中序数组
        int index = 0;
        for (index = 0; index < inorder.length; index++) {
            if (inorder[index] == root.val)
                break;
        }
        int[] inorderLeft = Arrays.copyOfRange(inorder, 0, index);
        int[] inorderRight = Arrays.copyOfRange(inorder, index + 1, inorder.length);

        //切割后续数组
        int[] postorderLeft = Arrays.copyOfRange(postorder, 0, inorderLeft.length);
        int[] postorderRight = Arrays.copyOfRange(postorder, inorderLeft.length, postorder.length-1);

        root.left = traversal(inorderLeft, postorderLeft);
        root.right = traversal(inorderRight, postorderRight);
        return root;
    }
}
~~~

给出前序和中序也是一样的思路，但是后序和前序不行

~~~Java
class Solution {

   
    /** 后序和中序
     * public TreeNode buildTree(int[] inorder, int[] postorder) {
     * return traversal(inorder, postorder);
     * }
     */

    /**
     * 前序和中序
     *
     * @param preorder 前序
     * @param inorder  中序
     * @return 二叉树根节点
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return traversal(inorder, preorder);
    }

    //1确定参数类别和返回值
    TreeNode traversal(int[] inorder, int[] postorder) {
        //2确定返回值
        if (postorder.length == 0) return null;

        //3确定单层的逻辑
        //找到根节点
        TreeNode root = new TreeNode(postorder[0]);
        if (postorder.length == 1) return root;

        //切割中序数组
        int index = 0;
        for (index = 0; index < inorder.length; index++) {
            if (inorder[index] == root.val)
                break;
        }
        int[] inorderLeft = Arrays.copyOfRange(inorder, 0, index);
        int[] inorderRight = Arrays.copyOfRange(inorder, (index + 1), inorder.length);

        //切割前序数组

        int[] postorderLeft = Arrays.copyOfRange(postorder, 1, inorderLeft.length+1);
        int[] postorderRight = Arrays.copyOfRange(postorder, inorderLeft.length+1, postorder.length - 1+1);

        root.left = traversal(inorderLeft, postorderLeft);
        root.right = traversal(inorderRight, postorderRight);
        return root;
    }
}
~~~